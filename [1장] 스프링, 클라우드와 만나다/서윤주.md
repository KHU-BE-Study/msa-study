## 마이크로서비스 아키텍처로 진화

### N-계층 아키텍처

→ 기능별 계층 분리

대표적인 계층 구성 (3계층 기준)

- 프레젠테이션 계층 : controller
- 비즈니스 계층 : service
- 데이터 접근 계층 : repository, DAO

### 모놀리스 아키텍처

→ 하나의 큰 배포 단위로 구성

모든 기능이 하나의 spring boot 애프리케이션 안에 다 때려박아넣음

### 마이크로서비스 아키텍처

→ 기능별로 서비스를 작게 나눠서 독립적으로 배포 및 실행

사용자 서비스 / 채팅 서비스 / 결제 서비스 각각을 별도 서버, DB를 가지고 동작하며 Kafka난 REST로 통신

팀의 코드, 소스 제어 레포지토리, 인프라스트럭터가 애플리케이션의 다른 부분과 완전히 독립적이기 때문에 상호 독립적으로 빌드, 배포, 테스트 가능

애플리케이션 구축 방법을 바꾸어야하는 이유

- 복잡성 증가
- 고객은 더 빠른 전달을 원함
- 고객 또한 안정적인 성능과 확정성 요구
- 고객은 애플리케이션을 언제든 사용할 수 있길 기대

<aside>
💡

작고, 단순하고, 분리된 서비스 = 확장 가능하고, 회복적이며, 유연한 애플리케이션

</aside>

## 스프링 마이크로서비스

### 스프링

→ 의존성 주입 프레임워크 

→ 객체 관계를 하드코딩하는 대신 convention과 annotation으로 외부화할 수 있어 효율적으로 관리 

→ 자바 클래스 사이에서 중개자 역할을 하며 의존성을 관리함

<aside>
💡

정리 : new로 직접 객체를 만들지 않고 스프링이 대신 생성하고 주입해줘서 다른 클래스들이 서로 사용할 수 있도록 만들어줌. 스프링이 중개자처럼 클래스들 사이의 의존 관계를 연결함

</aside>

### 스프링 부트

- 내장형 http 서버 제공
- 스프링 데이터, 스프링 시큐리티, 스프링 클라우드 같은 스프링 생태계와 통합 용이
- 다양한 개발 플러그인 제공
- 스프링 클라우드 프레임워크를 사용하면 사설 또는 공용 클라우드에 마이크로서비스를 간단하게 운영하고 배포할 수 있음.

### 마이크로서비스 작성 지침

- 적정 규모 : 서비스가 한 가지 책임 영역에 집중되도록 하려면 어떻게 해야하는가
→ 한 서비스는 하나의 도메인에만 집중 (AuthServcie, UserProfileService으로 나누는 것)
- 위치 투명성 : 서비스 클라이언트에 영향을 주지 않고 서비스 인스턴스를 추가하고 삭제하려면 물리적 위치를 어떻게 관리해야하는가
→ 서비스 위치는 클라가 몰라도 되도록 추상화함. 위치 정보는 서비스 디스커버리로 동적으로 관리 되도록
    - 예시
        
        ```yaml
        # application.yml 예시
        spring:
          cloud:
            gateway:
              routes:
                - id: user-service
                  uri: lb://USER-SERVICE
                  predicates:
                    - Path=/users/**
        ```
        
- 회복성(Resilience) : 서비스에 문제가 있을 때 서비스 클라이언트가 빠르게 실패하려면 어떻게 해야하는가
→ 장애가 발생하면 계속 요청을 시도하지 않고 실패 또는 대체동작(fallback)을 실행
    - 예시
        
        ✅ Resilience4j 사용하여 Circuit Breaker 설정
        
        ```java
        @CircuitBreaker(name = "userService", fallbackMethod = "fallback")
        public String getUser(String userId) {
            return restTemplate.getForObject("http://user-service/users/" + userId, String.class);
        }
        
        public String fallback(String userId, Throwable t) {
            return "Temporary error. Please try again later.";
        }
        ```
        
- 반복성 : 새로운 서비스가 시작할 때마다 항상 기존과 동일한 코드와 구성을 갖게 하려면 어떻게 해야하는가
→ CI/CD, Docker, Helm, 템플릿 리포지토리 등을 사용해 서비스 배포 및 설정을 표준화
- 확장성 : 서비스 간 종속성을 최소화하면서 애플리케이션을 신속히 확장하려면 어떻게 해야하는가
→ 서비스 간 강한 결합을 피하고, 비동기 메시징 또는 API 게이트웨이 패턴 등으로 느슨하게 연결

### 핵심 마이크로서비스 개발  패턴
<img src="https://github.com/user-attachments/assets/501d647a-867a-4024-9eba-0003d59aafb6" width="400"/>

### 마이크로서비스 라우팅 패턴 & 클라이언트 회복성
<img src="https://github.com/user-attachments/assets/5ac33e97-313c-4ed3-92a5-9151075e9cd2" width="600"/>

### 마이크로서비스 보안 패턴

- 인증 authentication : 서비스를 호출하는 서비스 클라가 누구인지 확인
- 인가(권한 부여) authorization : 마이크로서비스를 호출하는 서비스 클라이언트가 수행하려는 행동에 대한 수행 자격 여부를 확인
- 자격 증명 관리와 전파 : 서비스 클라가 한 트랜잭션에서 여러 서비스를 호출할 때 계속해서 자격 증명을 제시하지 않는 방법. 사용자를 인증 및 인가하고자 서비스 호출 간 전달되는 토큰을 발급받을 수 있는 OAuth2와 JWT같은 토큰 기반의 보안 표준 사용 방법

<aside>
💡

OAuth 2.0이란

사용자가 제삼자의 인증 서비스로 자신을 인증할 수 있는 토큰 기반의 보안 프레임워크이다. 사용자가 인증을 성공했다면, 매 요청마다 전달되어야 하는 토큰을 발급받는다.

주요목적 : 요청을 수행하기 위해 여러 서비스가 호출될 때, 요청을 처리하는 모든 서비스에 사용자의 자격 증명을 제시하지 않고 사용자를 인증하는 것

OAuth2.0 프로토콜의 토큰 형식으로 jwt를 사용한다.
OAuth = 인증 프로세스, jwt = 그 과정에서 주고받는 토큰 형식

</aside>
